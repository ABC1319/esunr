---
title: 温故知新，谈谈浏览器的原生事件
tags: [温故知新]
categories:
  - Front
  - JS
date: 2019-12-03 21:14:17
---

# 1. 前言

在现在越来越依赖框架之后，发现框架中的事件绑定已经滚瓜烂熟了，但是原生 HTML 的事件绑定却会发生有时候突然忘了的尴尬，并且在当时什么都不懂的时候，事件绑定这块一直是个坑。那么就来在这里温故一下原生的事件绑定，结合一些新的思想，来重新回顾一下这一块。

# 2. 事件处理器属性

任何一个 Element 对象都会有相对应的属性，事件处理器属性就是将事件绑定给我们的一个 Element 对象，使函数成为其自身的一个属性，最常见的方式：

```js
var btn = document.querySelector('button');
btn.onclick = function(){
  console.log(1);
}
```

我们还可以写成：

```js
var btn = document.querySelector('button');
function handleClick(){
  console.log(1);
}
btn.onclick = handleClick
```

那么问题来了，我们如何向一个 handle 函数传递一个参数呢？或许会写成：

```js
var btn = document.querySelector('button');
function handleClick(msg){
  console.log(msg);
}
btn.onclick = handleClick("this is a message")
```

这时候就会发现，在网页初始化时已经执行了该函数，此时 `btn.onclick` 的值已经被赋为了 `handleClikc` 函数执行后的返回值，这是因为我们在写入 `handleClick("this is a message")` 就意味着函数在此出执行，并将函数返回值赋值给等号前的对象，说的高大上一点就是做了一次 LHS 引用。

所以呢，如何解决呢？这一招就是从 React 事件绑定学来的，既然 `onclick` 的值是一个待执行函数，那么我们就在此定义一个函数将目标函数包裹起来，此时外部函数未执行，内部函数引用存放于堆内存中，此时也不会执行。于是我们就可以这样绑定：

```js
var btn = document.querySelector('button');
function handleClick(msg){
  console.log(msg);
}
btn.onclick = function() {
  handleClick("this is a message")
}
```

这里写一个事件节流函数，主要使用了这个方式传递节流函数的参数：

```html
<body>
  <button id="button">Click me!</button>
  <script>
    function throttle(fn, time) {
      let startTime = 0
      return function () {
        const args = Array.from(arguments)
        let currentTime = new Date().valueOf()
        if (currentTime - startTime > time) {
          fn.apply(this, args)
          startTime = currentTime
        }
      }
    }

    const throttleClick = throttle(function (msg) {
      console.log(msg);
    }, 1000)

    document.querySelector("#button").onclick = () => { throttleClick("msg") }
  </script>
</body>
```

# 3. 行内事件处理器

行内事件处理器就是将执行函数作为 HTML 标签的一个属性写入，但是这是一种非常原始的写法，这种习惯也并不好。

我们在这里需要注意的是，与 **事件处理器属性** 不同，行内事件处理器是将函数的执行写于行内，举一个例子：

```html
<button onclick="handleClick()">Click me!</button>
```

其意思就是当按钮被点击时，JS 引擎会解析 `onclick` 属性中的 js 代码并执行，而并非是事件处理器属性的为其绑定一个函数在其触发事件时被调用。就算是我们直接写一个纯 JS 代码也会被执行：

```html
<button onclick="alert('Hello, this is my old-fashioned event handler!');">Press me</button>
```

但这样我们就可以直接对函数传参，不过为了养成一个良好的编程习惯，还是不推荐使用。

# 4. addEventListener removeEventListener

> 新的事件触发机制被定义在 Document Object Model (DOM) Level 2 Events Specification, 这个细则给浏览器提供了一个函数 — addEventListener()。这个函数和事件处理属性是类似的，但是语法略有不同

这个解释的逻辑就是，我们为一个 Element 添加了一个事件监听器，当被监听的事件触发之后，就会执行监听器中我们传入的函数。这样的思想有一个显而易见的好处，那就是可以针对一个元素的同一事件，添加多个监听，比如：

```html
<body>
  <button id="btn">btn</button>
  <script>
    function click1() {
      console.log(1);
    }
    function click2() {
      console.log(2);
    }
    document.querySelector("#btn").addEventListener('click', click1)
    document.querySelector("#btn").addEventListener('click', click2)
  </script>
</body>
```

点击后输出：

```
1
2
```

> 未完待续


